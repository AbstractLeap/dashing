using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DatabaseSchemaReader;
using DatabaseSchemaReader.DataSchema;
using TopHat.Configuration;

namespace TopHat.Tools.ReverseEngineering
{
    public class Engineer : IEngineer
    {
        private IConvention convention;
        public Engineer() : this(new DefaultConvention()) { }

        public Engineer(IConvention convention)
        {
            this.convention = convention;
        }

        public IEnumerable<IMap> ReverseEngineer(DatabaseSchema schema)
        {
            var maps = new List<IMap>();
            foreach (var table in schema.Tables)
            {
                maps.Add(this.MapTable(table));
            }

            return maps;
        }

        private IMap MapTable(DatabaseTable table)
        {
            var map = new Map<object>();
            map.Table = table.Name;
            foreach (var column in table.Columns)
            {
                map.Columns.Add(this.MapColumn(map, column));
            }

            return map;
        }

        private KeyValuePair<string, IColumn> MapColumn(IMap map, DatabaseColumn column)
        {
            var mapColumn = new Column<object>();
            mapColumn.DbName = column.Name;
            mapColumn.DbType = (System.Data.DbType)column.DataType.ProviderDbType;
            mapColumn.IsAutoGenerated = column.IsIdentity;
            mapColumn.IsExcludedByDefault = false;
            mapColumn.IsIgnored = false;
            mapColumn.IsNullable = column.Nullable;
            mapColumn.IsPrimaryKey = column.IsPrimaryKey;
            if (mapColumn.IsPrimaryKey)
            {
                map.PrimaryKey = mapColumn;
            }

            if (column.Length.HasValue)
            {
                mapColumn.Length = (ushort)column.Length.Value;
            }

            if (column.Precision.HasValue)
            {
                mapColumn.Precision = (byte)column.Precision.Value;
            }

            if (column.Scale.HasValue)
            {
                mapColumn.Scale = (byte)column.Scale.Value;
            }

            mapColumn.Map = map;
            
            // figure out the relationship
            if (column.IsForeignKey)
            {
                mapColumn.Relationship = RelationshipType.ManyToOne;
                mapColumn.Name = this.convention.PropertyNameForManyToOneColumnName(column.Name);
            }
            else
            {
                mapColumn.Relationship = RelationshipType.None;
                mapColumn.Name = column.Name;
            }

            return new KeyValuePair<string, IColumn>(mapColumn.Name, mapColumn);
        }
    }
}
