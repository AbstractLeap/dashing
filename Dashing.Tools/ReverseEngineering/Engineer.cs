namespace Dashing.Tools.ReverseEngineering {
    using System;
    using System.Collections.Generic;

    using Dashing.Configuration;
    using Dashing.Extensions;

    using DatabaseSchemaReader.DataSchema;

    public class Engineer : IEngineer {
        private readonly IConvention convention;

        public Engineer()
            : this(new DefaultConvention()) {
        }

        public Engineer(IConvention convention) {
            this.convention = convention;
        }

        public IEnumerable<IMap> ReverseEngineer(DatabaseSchema schema) {
            var maps = new List<IMap>();
            foreach (var table in schema.Tables) {
                maps.Add(this.MapTable(table));
            }

            return maps;
        }

        private IMap MapTable(DatabaseTable table) {
            var map = new Map<object>();
            map.Table = table.Name;
            foreach (var column in table.Columns) {
                map.Columns.Add(this.MapColumn(map, column));
            }

            return map;
        }

        private KeyValuePair<string, IColumn> MapColumn(IMap map, DatabaseColumn column) {
            // figure out the type
            Type type;
            if (column.DataType == null) {
                // HACK throw an exception? log out as a warning??
                type = typeof(string);
            }
            else {
                type = Type.GetType(column.DataType.NetDataType);
            }

            var col = Activator.CreateInstance(typeof(Column<>).MakeGenericType(type));
            var mapColumn = col as IColumn;

            mapColumn.DbName = column.Name;
            mapColumn.DbType = type.GetDbType();
            mapColumn.IsAutoGenerated = column.IsIdentity;
            mapColumn.IsExcludedByDefault = false;
            mapColumn.IsIgnored = false;
            mapColumn.IsNullable = column.Nullable;
            mapColumn.IsPrimaryKey = column.IsPrimaryKey || column.IsIdentity; // HACK - MySql issue with primary keys?
            if (mapColumn.IsPrimaryKey) {
                map.PrimaryKey = mapColumn;
            }

            if (column.Length.HasValue) {
                mapColumn.Length = (ushort)column.Length.Value;
            }

            if (column.Precision.HasValue) {
                mapColumn.Precision = (byte)column.Precision.Value;
            }

            if (column.Scale.HasValue) {
                mapColumn.Scale = (byte)column.Scale.Value;
            }

            mapColumn.Map = map;

            // figure out the relationship
            if (column.IsForeignKey) {
                mapColumn.Relationship = RelationshipType.ManyToOne;
                mapColumn.Name = this.convention.PropertyNameForManyToOneColumnName(column.Name);
            }
            else {
                mapColumn.Relationship = RelationshipType.None;
                mapColumn.Name = column.Name;
            }

            return new KeyValuePair<string, IColumn>(mapColumn.Name, mapColumn);
        }
    }
}