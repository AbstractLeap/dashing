namespace Dashing.Engine.InMemory {
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using Dashing.Configuration;

    public class InMemoryTable<TEntity, TPrimaryKey>
        where TEntity : class, new() {
        private readonly Dictionary<TPrimaryKey, TEntity> entities;

        private readonly EntityCloner<TEntity> cloner;

        private readonly IMap<TEntity> map;

        private readonly InMemoryKeyGenerator<TPrimaryKey> primaryKeyGenerator;

        public InMemoryTable(IConfiguration configuration) {
            this.entities = new Dictionary<TPrimaryKey, TEntity>();
            this.cloner = new EntityCloner<TEntity>(configuration);
            this.map = configuration.GetMap<TEntity>();
            this.primaryKeyGenerator = new InMemoryKeyGenerator<TPrimaryKey>();
        }

        /// <summary>
        ///     Returns copies of the in memory store with the correct fetches applied
        /// </summary>
        /// <param name="fetches"></param>
        /// <param name="collectionFetches"></param>
        /// <returns></returns>
        public IEnumerable<TEntity> Query() {
            return Enumerable.Select(this.entities.Values, e => this.cloner.Clone(e));
        }

        public TEntity Get(TPrimaryKey id) {
            if (!this.entities.ContainsKey(id)) {
                return null;
            }

            return this.cloner.Clone(this.entities[id]);
        }

        /// <summary>
        ///     Inserts a new entity in to the table (creates a copy)
        /// </summary>
        /// <param name="entity"></param>
        public int Insert(TEntity entity) {
            TPrimaryKey primaryKey;
            if (this.map.PrimaryKey.IsAutoGenerated
                && ((TPrimaryKey)this.map.GetPrimaryKeyValue(entity)).Equals(default(TPrimaryKey))) {
                primaryKey = (TPrimaryKey)this.primaryKeyGenerator.GetNextPrimaryKey();
                this.map.SetPrimaryKeyValue(entity, primaryKey);
            }
            else {
                primaryKey = (TPrimaryKey)this.map.GetPrimaryKeyValue(entity);
                if (this.entities.ContainsKey(primaryKey)) {
                    throw new Exception("Duplicate key error - unable to insert entity as key already exists");
                }
            }

            var clone = this.cloner.Clone(entity);
            this.entities.Add(primaryKey, clone);
            return 1;
        }

        /// <summary>
        ///     Updates the in memory entity to match
        /// </summary>
        /// <param name="entity"></param>
        public int Update(TEntity entity) {
            var primaryKey = (TPrimaryKey)this.map.GetPrimaryKeyValue(entity);
            if (!this.entities.ContainsKey(primaryKey)) {
                return 0;
            }

            // just clone the update and replace
            var newInMemoryEntity = this.cloner.Clone(entity);
            this.entities[primaryKey] = newInMemoryEntity;
            return 1;
        }

        /// <summary>
        ///     deletes the in memory object
        /// </summary>
        /// <param name="entity"></param>
        public int Delete(TEntity entity) {
            var primaryKey = (TPrimaryKey)this.map.GetPrimaryKeyValue(entity);
            if (!this.entities.ContainsKey(primaryKey)) {
                return 0;
            }

            this.entities.Remove(primaryKey);
            return 1;
        }
    }
}