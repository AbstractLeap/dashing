namespace Dashing.Console.Weaving.Weavers {
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using Mono.Cecil;
    using Mono.Cecil.Cil;

    public class ForeignKeyGeneratedWeaver : BaseWeaver {
        public override int Precedence {
            get {
                return 0;
            }
        }

        public override void Weave(
            TypeDefinition typeDef,
            AssemblyDefinition assemblyDefinition,
            MapDefinition mapDefinition,
            Dictionary<string, List<MapDefinition>> assemblyMapDefinitions,
            Dictionary<string, AssemblyDefinition> assemblyDefinitions) {
            var boolTypeDef = typeDef.Module.Import(typeof(bool));

            var classHierarchy = this.GetClassHierarchy(typeDef);
            var totalInChain = classHierarchy.Count;
            var baseTypeDef = classHierarchy.Pop();

            // add a backing field to the base class indicating that the instance was generated by the code below
            // and therefore access to other properties should throw an error
            if (!baseTypeDef.Fields.Any(f => f.Name == IsGeneratedViaForeignKeyFieldName)) {
                var isGeneratedViaForeignKeyField = new FieldDefinition(IsGeneratedViaForeignKeyFieldName, FieldAttributes.Public, boolTypeDef);
                baseTypeDef.Fields.Add(isGeneratedViaForeignKeyField);
                this.MakeNotDebuggerBrowsable(baseTypeDef.Module, isGeneratedViaForeignKeyField);
            }

            // now we go through every non pk property and add a check for the above field and throw if it's true
            // this prevents accidental access to a non-fetched property
            foreach (var columnDefinition in mapDefinition.ColumnDefinitions.Where(c => !c.IsPrimaryKey)) {
                var propDef = this.GetProperty(typeDef, columnDefinition.Name);

                var index = 0;
                var il = propDef.GetMethod.Body.Instructions;
                var originalFirstIntruction = il.First();
                il.Insert(index++, Instruction.Create(OpCodes.Ldarg_0)); 
                il.Insert(index++, Instruction.Create(OpCodes.Ldfld, this.GetField(typeDef, IsGeneratedViaForeignKeyFieldName)));
                il.Insert(index++, Instruction.Create(OpCodes.Brfalse, originalFirstIntruction));
                il.Insert(index++, Instruction.Create(OpCodes.Ldstr, string.Format("You can not access property {0} on type {1} as it has not been fetched", columnDefinition.Name, typeDef.Name)));
                il.Insert(index++, Instruction.Create(OpCodes.Newobj, typeDef.Module.Import(typeof(InvalidOperationException).GetConstructor(new Type[] { typeof(string) }))));
                il.Insert(index, Instruction.Create(OpCodes.Throw));
            }
        }
    }
}